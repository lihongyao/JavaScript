# 概述

[字符串 >>](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) 是被 **双引号** 或 **单引号** 包含的内容，可以包括数字、运算符、各国语言、特殊编码字符，甚至 HTML 标签。简单来说，任何符合在引号内的内容都可以被称为字符串。

📖 **字符串引号使用规则** *

在使用字符串的引号时，需要注意如果一个字符串已经使用了某种引号，再在字符串内部使用引号时，需要使用不同的引号类型。例如，双引号内使用单引号，单引号内使用双引号，或者使用转义符 `\` 对相同的引号进行转义。在多层引号嵌套的情况下，该规则依然适用：

```javascript
const str1 = "Hello, I'm Petter!";
const str2 = 'How do you think about "JavaScript"?';
const str3 = "设置字体的'颜色'代码是：<p style=\"color:red;\">";	
```

需要了解的一点是，字符串不能直接分成多行写，否则浏览器会报错。如果字符串过长，想要分行写以便视觉上更清晰，可以使用以下方式：

```javascript
const str = "这是一个" + 
          "分行写的" +
          "字符串";
console.log(str); // 输出：这是一个分行写的字符串
```

📖 **模板字符串**

ES6 引入了 **模板字符串**，使用反引号（**\`**）进行标识。

当使用模板字符串时，可以在字符串中插入变量或表达式，通过 `${}` 来引用，这使得字符串拼接更加简洁和可读。

```js
const name = 'John';
const message = `Hello, ${name}!`;
```

> 提示：
>
> 1、模板字符串中嵌入变量使用 `${}`，`${}` 中可以是变量或表达式。
>
> 2、如果使用模板字符串表示多行字符串，所有的空格、缩进和换行都会保留在输出之中。

# 转义符

反斜杠 `\` 在字符串中用作**转义字符**（Escape Character），用于表示特殊字符或实现特定功能。

以下是常用转义字符及其 Unicode 表示：

```js
\n（或：\u000A）用于表示：换行符
\t（或：\u0009）用于表示：制表符
\'（或：\u0027）用于表示：单引号
\"（或：\u0022）用于表示：双引号
\\（或：\u005C）用于表示：反斜杠
```

> 注意事项：
>
> 1. 在普通字符前使用 `\` 时，反斜杠会被自动忽略（如 `\a` 输出为 `a`）。
> 2. 若需直接输出反斜杠，需转义自身，即 `\\` → `\`。
> 3. 其他常见转义符还包括 `\r`（回车）、`\b`（退格）等，具体取决于语言环境。

> 提示：Unicode 表示法（如 `\u000A`）适用于需要显式编码的场景，但通常转义符（如 `\n`）更直观易用。

# UNICODE

## 字符的 Unicode 表示法

JavaScript 允许使用 `\uxxxx` 形式表示一个字符，其中 xxxx 是字符的 Unicode 码点。每个 Unicode 码点对应一个字符，例如 `\u00A9` 是版权符号“©”。

在 js 中，所有字符都使用 Unicode 编码表示，且不仅仅以 Unicode 储存字符，还允许直接使用 Unicode 编号来表示字符。当解析代码时，js 会自动识别字符是以字面形式表示还是 Unicode 形式表示。输出给用户时，所有字符会被转成字面形式。换句话说，任何 js 中允许的字符都可以通过 Unicode 来表示。

```javascript
"\u738b\u8005\u8363\u8000"
"王者荣耀"
```

## **UTF-16 储存格式**

JavaScript 内部使用 UTF-16 编码存储字符，每个字符固定占用 2 字节（16 位）。这种存储方式决定了字符的表示方法：

对于 Unicode 码点在 `\u0000` ~ `\uFFFF` 之间的字符，可以直接使用 `\uxxxx` 表示：

```js
'\u0041' // "A"
'\u4E2D' // "中"
```

当字符的 Unicode 码点超过 `\uFFFF` 时，需要使用两个 UTF-16 单元（即4字节）来表示：

```js
// 错误写法：会被解析为 \u20BB + "7"
'\u20BB7' // 显示为"₻7"

// 正确写法：使用代理对
'\uD842\uDFB7' // "𠮷"（码点U+20BB7）
```

ES6 引入了 `\u{码点}` 表示法，可以直接表示任意 Unicode 字符：

```js
'\u{20BB7}' // "𠮷"
'\u{1F600}' // "😀"
```

## str.codePointAt(idx)   

[`codePointAt()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt) 方法返回一个非负整数，该整数是从给定索引开始的字符的 Unicode 码位值。

```javascript
/**
 * 函数封装：将字符串转为Unicode编码
 */
Object.prototype.toUnicodeString = function (str) {
  const s = str || this.valueOf();
  let res = "";
  for (let i = 0, len = s.length; i < len; i++) {
    res += `\\u{${s.codePointAt(i).toString(16)}}`;
  }
  return res;
};
console.log("王者荣耀".toUnicodeString()); // "\u738b\u8005\u8363\u8000"
```

## String.fromCodePoint()

[ `String.fromCharCode(numCode)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint) 方法将数字编码转换为字符，`numCode` 是字符的数字编码值。

```javascript
const str = "帅";
const numCode = str.codePointAt(0); // 24069
const oriStr = String.fromCodePoint(numCode); // "帅"
```

# 包装对象 *

在 JavaScript 中，虽然存在"一切皆对象"的说法，但实际上基本类型（primitive types）本身并不是对象。包装对象（Wrapper Objects）是 JavaScript 为了能让基本类型也能调用方法而设计的特殊机制。

## 包装对象概述

JavaScript 为以下三种基本类型提供了对应的包装对象：

1. `Number`：用于包装数值类型
2. `String`：用于包装字符串类型
3. `Boolean`：用于包装布尔值类型

## 自动装箱（Auto-boxing）机制

当对基本类型值调用方法时，JavaScript 会自动执行以下操作：

当对基本类型值调用方法时，JavaScript 会自动执行以下操作：

1. 临时创建一个对应的包装对象
2. 调用方法
3. 立即销毁该临时对象

```js
let str = "hello";
console.log(str.length); // 5

// 等价于：
// let temp = new String(str);
// console.log(temp.length);
// temp = null;
```

## 重要特性

1. **临时性**：包装对象仅在方法调用期间存在

2. **严格区分**：基本类型 !== 包装对象

   ```js
   typeof "abc" // "string"
   typeof new String("abc") // "object"
   ```

3. **`valueOf()`**：可获取包装对象的原始值

   ```js
   let numObj = new Number(123);
   console.log(numObj.valueOf()); // 123
   ```

## 使用建议

1. 通常情况下直接使用基本类型即可

2. 避免显式创建包装对象（可能导致意外行为）

3. 需要扩展方法时，建议修改原型而非创建包装对象

   ```js
   String.prototype.reverse = function() {
     return this.split('').reverse().join('');
   };
   "abc".reverse(); // "cba"
   ```

> **注意**：`null` 和 `undefined` 没有包装对象，尝试访问它们的属性会抛出错误。

# 字符串对象 *

## 构造函数

```javascript
const str = "Hello, world!";
const str = 'Hello, world!';
const str = `Hello, world!`;  // ES6

const str = new String("Hi!");
const str = new Object("Hi!");
```

## 属性

- [length](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/length)：字符串长度

## 方法

### 查询相关

- [`.at(index)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/at)：查询指定下标位置的字符
- [`.charAt(index)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charAt)：查询指定下标位置的字符
- [`.indexof(searchValue, position)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)：查询下标
- [`.lastIndexOf(searchValue[, fromIndex])`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf)：查询下标
- [`.match(regexp)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match)：检索返回一个字符串匹配正则表达式的结果
- [`.matchAll(regexp)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll)：检索返回一个字符串匹配正则表达式的 **所有** 结果
- [`.search()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search)：搜索字符
- [`.startsWith(searchString[, position])`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith)：查询头*（ES6）*
- [`.endsWith(searchString[, length])`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)：查询尾*（ES6）*
- [`.includes(searchString[, position])`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes)：是否包含*（ES6）*

### 拼接

- `+`：运算法加号
- [`.concat(str2, [, ...strN])`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/concat)

### 截取 

- [`.slice(beginIndex[, endIndex])`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/slice)
- [`.substring(indexStart, [indexEnd])`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substring)

**`slice` vs. `substring`**

| 特性                  | `slice()`            | `substring()`                       |
| --------------------- | -------------------- | ----------------------------------- |
| 支持负数参数          | 是                   | 否                                  |
| `start` 大于 `end` 时 | 返回空字符串         | 交换 `start` 和 `end`，提取子字符串 |
| 参数是负数时          | 从字符串末尾开始计算 | 被当作 0 处理                       |

### 去除空格

- [`.trim()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trim)：去除两端空格

- [`.trimStart()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart)：去除左侧空格
- [`.trimEnd()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd)：去除右侧空格

### 大小写转换

- [`.toLowerCase()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase)：转小写

- [`.toUpperCase()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase)：转大写

### 比较

- [`.localeCompare()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)：字符串比较

### 替换

语法形式为：

```js
str.replace(regexp|substr, newSubStr|function)
```

- `regexp`：正则表达式（匹配条件）
- `substr`：字符串（匹配条件）
- `newSubStr`：替换值
- `function`：替换值（函数类型）

示例：

```javascript
const str = "Hello, world!";
str.replace("world", "china"); // "Hello, china!"
```

`replace`只会替换第一次匹配到的字段，不能完全替换：

```js
const str = "#fffff#";
str.replace("f", "o"); // "#offff#"
```

上述例子中只会替换第一个f，如果想要全局匹配替换，我们可以使用正则表达式，如下所示：

```js
// g → global：全局模式
str.replace(/f/g, "o"); // "#ooooo#"
```

> **提示**：你也可以通过 [`.replaceAll()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll) 方法实现全局匹配替换。

`replace` 方法的第2个参数也可以是一个函数，如下所示：

```javascript
"Tel:15888888888;".replace(/(\d{3})(\d{4})(\d{4})/, (match, $1, $2, $3, offset, string) => {
    console.log(match, $1, $2, $3, offset, string);
    return `${$1} ${$2} ${$3}`;
})
// 15888888888 158 8888 8888 4 Tel:15888888888;
// Tel:158 8888 8888;
```

可以看到，当参数为函数时，其中各参数表示：

- `match`：匹配的字符串（`15888888888`）。
- `$1`：如果 `replace` 方法的第1个参数是正则表达式，则 `$1` 表示第1个括号（组匹配）匹配的字符串，以此类推，`$2` / `$3` 表示第2 / 3 个括号匹配字符串。
- `offset`：偏移量，表示被匹配到的字符串在原始字符串中的位置。
- `string`：被匹配的原始字符串。

替换字符串可以插入下面的特殊变量名：

| 变量名   | 代表的值                                                     |
| -------- | ------------------------------------------------------------ |
| $$       | 插入一个 "$"。                                               |
| $&       | 插入匹配的子串。                                             |
| $`       | 插入当前匹配的子串左边的内容。                               |
| $'       | 插入当前匹配的子串右边的内容。                               |
| $*n*     | 假如第一个参数是 [`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始。如果不存在第 n个分组，那么将会把匹配到到内容替换为字面量。比如不存在第3个分组，就会用“$3”替换匹配到的内容。 |
| $\<Name> | 这里 *`Name`*  是一个分组名称。如果在正则表达式中并不存在分组（或者没有匹配），这个变量将被处理为空字符串。只有在支持命名分组捕获的浏览器中才能使用。 |

我们简单应用下：

```javascript
// 1. 加密手机
"15888888888".replace(/(\d{3})(\d{4})(\d{4})/, "$1 *** $3")
// -> '158 *** 8888'

// 2. 交换两个单词
const re = /(\w+)\s(\w+)/;
const str = "John Smith";
const newstr = str.replace(re, "$2, $1");
// Smith, John
console.log(newstr);
```

### 填充

- [`.padStart(targetLength, padString)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart)：用另一个字符串填充当前字符串（如果需要会重复填充），直到达到给定的长度。填充是从当前字符串的 **开头** 开始的。
- [`.padEnd(targetLength, padString)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd)：用另一个字符串填充当前字符串（如果需要会重复填充），直到达到给定的长度。填充是从当前字符串的 **末尾** 开始的。

代码示例：

```javascript
const month = "1";
month < 10 ? month.padStart(2, '0') : month; // '01'
```

### 切割数组

- [`.split()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split)

## 重复

- [`.repeat()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/repeat)*（ES6）*

# 编码

## Base64转码

**Base64** 是一种编码方法，用于将任意字符（如二进制数据、文本等）转化为可打印字符。最初的目的是确保数据能在系统中安全地传输，避免一些特殊字符（例如空格、回车符等）导致问题。Base64 编码可以用来在传输过程中将二进制数据转换为字符串形式，常用于电子邮件和 URL 编码。

JavaScript 提供了两个常用方法来进行 Base64 编码和解码：

- [btoa(stringToEncode)](https://developer.mozilla.org/zh-CN/docs/Web/API/btoa)：将字符串转换为 Base64 编码

- [atob(encodedData)](https://developer.mozilla.org/zh-CN/docs/Web/API/atob)：将 Base64 编码的字符串解码为原始字符串（解码）

**示例代码**：

```js
// 1. 编码字符串
const encodedData = btoa('Hello, world!'); 
console.log(encodedData); // → SGVsbG8sIHdvcmxkIQ==

// 2. 解码字符串
const decodedData = atob(encodedData); 
console.log(decodedData); // → Hello, world!
```

### **Base64 编码限制**

`btoa()` 只能处理 **ASCII 字符**，如果传入的字符串中包含需要超过一个字节表示的字符（如中文、表情符号等），则会抛出错误。例如：

```js
const ok = "a";
console.log(ok.codePointAt(0).toString(16)); // 61：占用 < 1 byte

const notOK = "✓";
console.log(notOK.codePointAt(0).toString(16)); // 2713：占用 > 1 byte

console.log(btoa(ok));    // YQ==
console.log(btoa(notOK)); // error
```

#### **解决 Unicode 编码问题**

Base64 仅将二进制数据作为其输入。而在 js 字符串中，这意味着每个字符只能使用一个字节表示。所以，如果你将一个字符串传递给 `btoa()`，而其中包含了需要使用超过一个字节才能表示的字符，你就会得到一个错误，因为这个字符串不能被看作是二进制数据：

**方法 1：将 Unicode 字符转为字节（不推荐）**

通过将字符串的每个 Unicode 单元转换为字节，可以解决 Unicode 编码问题：

```js
function b64Encode(str) {
  function toBinary(string) {
    const codeUnits = new Uint16Array(string.length);
    for (let i = 0; i < codeUnits.length; i++) {
      codeUnits[i] = string.charCodeAt(i);
    }
    const charCodes = new Uint8Array(codeUnits.buffer);
    let result = '';
    for (let i = 0; i < charCodes.byteLength; i++) {
      result += String.fromCharCode(charCodes[i]);
    }
    return result;
  }
  return btoa(toBinary(str));
}

function b64Decode(b64String) {
  function fromBinary(binary) {
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < bytes.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    const charCodes = new Uint16Array(bytes.buffer);
    let result = '';
    for (let i = 0; i < charCodes.length; i++) {
      result += String.fromCharCode(charCodes[i]);
    }
    return result;
  }
  return fromBinary(atob(b64String));
}

const b64String = b64Encode('中国!!!');
console.log(b64String); // → LU79ViEAIQAhAA==
console.log(b64Decode(b64String)); // → 中国!!!
```

**方法 2：使用 encodeURIComponent（推荐）**

使用 encodeURIComponent 和 decodeURIComponent 函数处理 Unicode 字符串：

```js
function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function b64Decode(b64String) {
  return decodeURIComponent(atob(b64String));
}

const b64String = b64Encode('中国!!!');
console.log(b64String); // → JUU0JUI4JUFEJUU1JTlCJUJEISEh
console.log(b64Decode(b64String)); // → 中国!!!
```

## encodeURI vs. encodeURIComponent

encodeURI 和 encodeURIComponent 都是用于对 URI 进行编码，但它们的行为有所不同：

- [encodeURI](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI)：编码，不可以编码特殊字符（`#`、`/`、`&` 等）
- [decodeURI](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURI)：解码，不可以解码特殊字符（`#`、`/`、`&` 等）

- [encodeURIComponent](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent)：编码，可以编码特殊字符（`#`、`/`、`&` 等）

- [decodeURIComponent](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent)：解码，可以解码特殊字符（`#`、`/`、`&` 等）

代码示例：

```js
const uri = 'http://lee-coding.cn#top?id=1&k=small';
console.log(encodeURI(uri)); // → http://lee-coding.cn#top?id=1&k=small
console.log(encodeURIComponent(uri)); // → http%3A%2F%2Flee-coding.cn%23top%3Fid%3D1%26k%3Dsmall
```

# 课后练习

```markdown
1. 将字符串 “hello” 逆序输出为 “olleh”

2. 删除字符串 “01i13P47h2o39n32e09” 中的所有数字，输出结果

3. 定义一个字符串 ”CHINESE“，将其输出为 “Chinese“ 

4. 统计 ”warriors” 单词中，“r“字母出现的次数

5. 将字符串 ”-_-” 中的 “_“ 替换成 ”$”

6. 将字符串”border-bottom-color” 转换成驼峰命名”borderBottomColor”

7. 输入身份证号，点击按钮，显示出生年月，输出格式为："出生年月：xxxx年xx月xx日"
  > 提示：
  - 获取元素：document.querySelector(CSS选择器);
  - 点击事件：el.onclick = function(){};
  - 获取输入框的值：el.value;
  - 设置元素显示内容：el.textContent = "";
```

